import { Coordinate } from '../types';
import { getBitBoardValue } from '../bitboard';

import _pieceData from './pieces.json'; // https://www.gottfriedville.net/blokus/set.png
import _orientationData from './piece-orientations.json';
import _orientationBitboardData from './piece-orientations-bitboard.json';
import _orientationBitboardHaloData from './piece-orientations-bitboard-halo.json';
import _rrData from './piece-rr.json';
import _cornersData from './piece-corners.json';
import _shortBoundingBoxData from './piece-short-bounding-box.json';
import _cornerAttachersData from './piece-corner-attachers.json';
import { Board } from '../board';
import { coordinateInBounds } from './movegen-utils';

export type PieceData = Coordinate[];

// index into the "pieceData"
export type PieceType = number;
export type Player = 0 | 1;

// 16 bit integer bitfield
export type PackedMove = number;

const MOVE_ORIENTATION_MASK = 0x7;
const MOVE_Y_MASK = 0x78;
const MOVE_X_MASK = 0x780;
const MOVE_TYPE_MASK = 0xf800;
const MOVE_PLAYER_BIT = 0x10000;

export const getMoveOrientation = (packedMove: PackedMove): number => {
    return packedMove & MOVE_ORIENTATION_MASK;
};

export const getMoveLocation = (packedMove: PackedMove): Coordinate => {
    const x = (packedMove & MOVE_X_MASK) >> 7;
    const y = (packedMove & MOVE_Y_MASK) >> 3;

    return { x, y };
};

export const getMovePieceType = (packedMove: PackedMove): number => {
    return (packedMove & MOVE_TYPE_MASK) >> 11;
};

export const getMovePlayer = (packedMove: PackedMove): Player => {
    const player = (packedMove & MOVE_PLAYER_BIT) >> 16;

    return player as Player;
};

// Sentinel value, invalid for an actual move since there cannot be a move with piece type 31.
export const NULL_MOVE = 0x7800;

export interface PlacedPiece {
    pieceType: PieceType;
    location: Coordinate;
    player: Player;
    orientation: number;
}

export const serializePlacedPiece = (placedPiece: PlacedPiece): PackedMove => {
    return (
        placedPiece.orientation |
        (placedPiece.location.y << 3) |
        (placedPiece.location.x << 7) |
        (placedPiece.pieceType << 11) |
        (placedPiece.player << 16)
    );
};

/**
 * A move is either a placement of a piece or a transfer of the turn to the other player.
 */
export type Move = PackedMove;

export interface Permutation {
    rotation: number;
    reflection: boolean;
    data: PieceData;
}

export const pieceData: Readonly<PieceData[]> = _pieceData;
export const orientationData: Readonly<PieceData[][]> = _orientationData;
export const orientationBitBoarddata: Readonly<number[][][]> = _orientationBitboardData;
export const orientationBitBoardHaloData: Readonly<number[][][]> = _orientationBitboardHaloData;
export const RRData: Readonly<number[][]> = _rrData;
export const cornersData: Readonly<PieceData[][]> = _cornersData;
export const cornerAttachersData: Readonly<PieceData[][]> = _cornerAttachersData;
export const shortBoundingBoxData: Readonly<[number, number][][]> = _shortBoundingBoxData as [
    number,
    number,
][][];

export const getOrientationData = (pieceType: PieceType, orientation: number) => {
    return orientationData[pieceType][orientation];
};

export type StartPosition = 'middle' | 'corner' | 'middle-blokee';

/**
 * Given a pseudo-legal move generated by intermediate operations in functions like getLegalMovesFrom, verifies that it is legal
 * Which means that none of it's tiles are adjacent to any of the players, nor intersecting any other placed piece
 * @param pseudoLegalMove The pseudolegal move to test
 * @param state The context within which it's legality is checked
 * @returns Whether the move is legal
 */
export const isMoveLegal = (pseudoLegalMove: Move, state: Board): boolean => {
    // We assume if a null move was generated, it was legal
    // We don't check if there is actually a reason for a null move - like if there are zero valid moves
    if (pseudoLegalMove === NULL_MOVE) {
        return true;
    }

    const toMove = getMovePlayer(pseudoLegalMove);
    const location = getMoveLocation(pseudoLegalMove);

    // otherwise, check if we already placed this piece
    const myPlacedPiece = [state.state.playerARemaining, state.state.playerBRemaining][toMove];
    if (!(myPlacedPiece & (1 << getMovePieceType(pseudoLegalMove)))) {
        return false;
    }

    const myBitBoard = [state.state.playerABitBoard, state.state.playerBBitBoard][toMove];
    const opponentBitBoard = [state.state.playerBBitBoard, state.state.playerABitBoard][toMove];

    const shortBoundingBox =
        shortBoundingBoxData[getMovePieceType(pseudoLegalMove)][
            getMoveOrientation(pseudoLegalMove)
        ];

    const bottomRightBB = {
        x: location.x + shortBoundingBox[0],
        y: location.y + shortBoundingBox[1],
    };
    if (!coordinateInBounds(bottomRightBB) || !coordinateInBounds(location)) {
        return false;
    }
    // this is an array of numbers, representing the piece
    // for example, [1,1,1,3] corresponds to
    // +------
    // |x
    // |x
    // |x
    // |xx
    // i.e. the L piece
    const pieceBitboard =
        orientationBitBoarddata[getMovePieceType(pseudoLegalMove)][
            getMoveOrientation(pseudoLegalMove)
        ];

    // it's easier to check the opponent bitboards first: check if there is no intersection
    for (let bitboardY = 0; bitboardY < pieceBitboard.length; bitboardY++) {
        // translate the row right by the x coordinate of the piece
        const bitBoardRow = pieceBitboard[bitboardY] << location.x;
        // now compare it with the actual bitboard
        const gameRow = opponentBitBoard[bitboardY + location.y];
        if (bitBoardRow & gameRow) {
            return false;
        }
    }

    // check if there is any intersection with my bitboard
    // for this we also need to do a "halo" - checking 4 tiles around each piece
    // thus for each row, we need to add a couple more options: the row, the rows above and below it, and the row shifted left and right
    const haloData =
        orientationBitBoardHaloData[getMovePieceType(pseudoLegalMove)][
            getMoveOrientation(pseudoLegalMove)
        ];

    for (let bitboardY = 0; bitboardY < pieceBitboard.length + 2; bitboardY++) {
        if (location.y + bitboardY - 1 < 0 || location.y + bitboardY - 1 >= myBitBoard.length) {
            continue;
        }
        const cachedHalo = haloData[bitboardY] << location.x;

        // shift by 1 to match the halo data
        const gameRow = myBitBoard[bitboardY + location.y - 1] << 1;
        if (cachedHalo & gameRow) {
            return false;
        }
    }

    return true;
};

/**
 * Get the set of moves that originate from the `from` coordinate, usually a corner to another placed piece, of a given piece type.
 * @param from The coordinate through which the piece must go through
 * @param piece The type of piece
 * @param state Current board state
 * @returns An array of legal moves
 */
export const getLegalMovesFrom = (from: Coordinate, piece: PieceType, state: Board): Move[] => {
    const moves: Move[] = [];

    //TODO: could we hardcode every single valid placement?
    //TODO: can we always say that the two bounding boxes must not interstect? edit: no
    // aa
    // a b
    // a b
    //  bb

    // go over each orientation
    for (let i = 0; i < orientationData[piece].length; i++) {
        const orientationCorners = cornersData[piece][i];

        // each corner of the orientation
        for (const corner of orientationCorners) {
            // position of the (0,0) tile
            const pieceMiddle = { x: from.x - corner.x, y: from.y - corner.y };

            if (!coordinateInBounds(pieceMiddle)) {
                continue;
            }

            let placedPiece: PlacedPiece = {
                location: pieceMiddle,
                player: state.state.toMove,
                pieceType: piece,
                orientation: i,
            };
            const move = serializePlacedPiece(placedPiece);

            moves.push(move);
        }
    }

    return moves.filter((p) => isMoveLegal(p, state));
};

/**
 * Blokee's middle start position is unique in that the move must be entirely contained within your quadrant
 * @param move
 */
const isMoveBlokeeLegal = (move: PlacedPiece, pieceTiles: PieceData) => {
    return pieceTiles.every((relCoord) => {
        const absolute = { x: relCoord.x + move.location.x, y: relCoord.y + move.location.y };
        if (move.player === 0) {
            // bottom left
            return absolute.x <= 6 && absolute.y > 6;
        } else {
            // top right
            return absolute.x > 6 && absolute.y <= 6;
        }
    });
};

/**
 * Generates the set of valid moves for the first turn of the game, which is different.
 * The placed piece must simply cover the starting position, which can be either in the corner or near the middle.
 * @param board The current state
 * @returns
 */
const generateFirstMove = (board: Board): Move[] => {
    const startPos = board.startPositions[board.state.toMove];

    if (board.state.nullMoveCounter !== 0) {
        throw new Error('Null move counter is not 0 at the beginning of the game?');
    }

    const moves: Move[] = [];
    for (let piece = 0; piece < 21; piece++) {
        // go over each orientation
        for (let i = 0; i < orientationData[piece].length; i++) {
            const pieceTiles = orientationData[piece][i];

            // each tile of the piece, center it over the starting position
            for (const tile of pieceTiles) {
                // position of the (0,0) tile
                const pieceMiddle = { x: startPos.x - tile.x, y: startPos.y - tile.y };
                let placedPiece: PlacedPiece = {
                    location: pieceMiddle,
                    player: board.state.toMove,
                    pieceType: piece,
                    orientation: i,
                };

                // special rules
                if (
                    board.state.startPosName === 'middle-blokee' &&
                    !isMoveBlokeeLegal(placedPiece, pieceTiles)
                ) {
                    continue;
                }

                moves.push(serializePlacedPiece(placedPiece));
            }
        }
    }
    return moves.filter((p) => isMoveLegal(p, board));
};

/**
 * Get all the legal moves from the current player to move
 * @param board The current board state
 * @returns
 */
export const getAllLegalMoves = (board: Board): Move[] => {
    //for all of my already placed pieces:
    //  - find their "corner attachers" (filter out occupied ones)
    //  - for each of the "corner attachers":
    //      - for each of my non-placed pieces
    //          - for each orientation of that non-placed piece
    //              - check if that orientation of that piece in that location intersects or is adjacent to any other piece

    if (board.gameOver()) {
        return [];
    }

    const myPlacedPieces = board.state.pieces.filter(
        (p) => getMovePlayer(p) === board.state.toMove
    );

    if (myPlacedPieces.length === 0) {
        return generateFirstMove(board);
    }

    // If not generating the first move, used the cached moves for each corner
    let moves: Move[] = [];
    if (board.state.toMove === 0) {
        moves = Array.from(board.state.playerACornerMoves.values()).flat();
    } else {
        moves = Array.from(board.state.playerBCornerMoves.values()).flat();
    }

    // deduplicate
    const uniqueMoves = Array.from(new Set(moves));
    /*
    const myState =
        board.state.toMove === 0 ? board.state.playerARemaining : board.state.playerBRemaining;
    const moves: Move[] = [];

    for (const placedPiece of myPlacedPieces) {
        // Find the corners of my placed pieces
        //x  x
        // oo
        // o x
        // oo
        //x  x
        const cornerAttachers =
            cornerAttachersData[getMovePieceType(placedPiece)][getMoveOrientation(placedPiece)];
        for (const cornerAttacher of cornerAttachers) {
            const cornerAbsolute: Coordinate = {
                x: cornerAttacher.x + getMoveLocation(placedPiece).x,
                y: cornerAttacher.y + getMoveLocation(placedPiece).y,
            };

            if (!coordinateInBounds(cornerAbsolute)) {
                continue;
            }

            // corner attacher must be unoccupied for us to place something there

            const playerATile = getBitBoardValue(board.state.playerABitBoard, cornerAbsolute);
            const playerBTile = getBitBoardValue(board.state.playerBBitBoard, cornerAbsolute);
            if (playerATile || playerBTile) {
                continue;
            }

            for (let unplacedPiece = 0; unplacedPiece < 21; unplacedPiece++) {
                if (!(myState & (1 << unplacedPiece))) {
                    continue;
                }

                moves.push(...getLegalMovesFrom(cornerAbsolute, unplacedPiece, board));
            }
        }
    }*/

    if (uniqueMoves.length === 0) {
        uniqueMoves.push(NULL_MOVE);
    }

    return uniqueMoves;
};
